#!/usr/bin/env bash
# This script was generated by bashly 0.7.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.wrapper
run_gvm() {
  # :command.master_script

  # :command.version_command
  version_command() {
    echo "$version"
  }

  # :command.usage
  gvm_usage() {
    if [[ -n $long_usage ]]; then
      printf "gvm - Simple Golang Version Manager\n"
      echo

    else
      printf "gvm - Simple Golang Version Manager\n"
      echo

    fi

    printf "Usage:\n"
    printf "  gvm [command]\n"
    printf "  gvm [command] --help | -h\n"
    printf "  gvm --version | -v\n"
    echo
    # :command.usage_commands
    printf "Commands:\n"
    echo "  init      Initialize environment to support gvm"
    echo "  list      List currently installed versions of Go"
    echo "  use       Set a version of Go as the default version to use"
    echo "  install   Install a version of Go"
    echo

    if [[ -n $long_usage ]]; then
      printf "Options:\n"
      # :command.usage_fixed_flags
      echo "  --help, -h"
      printf "    Show this help\n"
      echo
      echo "  --version, -v"
      printf "    Show version number\n"
      echo

    fi
  }

  # :command.usage
  gvm_init_usage() {
    if [[ -n $long_usage ]]; then
      printf "gvm init - Initialize environment to support gvm\n"
      echo

    else
      printf "gvm init - Initialize environment to support gvm\n"
      echo

    fi

    printf "Usage:\n"
    printf "  gvm init\n"
    printf "  gvm init --help | -h\n"
    echo

    if [[ -n $long_usage ]]; then
      printf "Options:\n"
      # :command.usage_fixed_flags
      echo "  --help, -h"
      printf "    Show this help\n"
      echo

    fi
  }

  # :command.usage
  gvm_list_usage() {
    if [[ -n $long_usage ]]; then
      printf "gvm list - List currently installed versions of Go\n"
      echo

    else
      printf "gvm list - List currently installed versions of Go\n"
      echo

    fi

    printf "Usage:\n"
    printf "  gvm list\n"
    printf "  gvm list --help | -h\n"
    echo

    if [[ -n $long_usage ]]; then
      printf "Options:\n"
      # :command.usage_fixed_flags
      echo "  --help, -h"
      printf "    Show this help\n"
      echo

    fi
  }

  # :command.usage
  gvm_use_usage() {
    if [[ -n $long_usage ]]; then
      printf "gvm use - Set a version of Go as the default version to use\n"
      echo

    else
      printf "gvm use - Set a version of Go as the default version to use\n"
      echo

    fi

    printf "Usage:\n"
    printf "  gvm use [GO_VERSION]\n"
    printf "  gvm use --help | -h\n"
    echo

    if [[ -n $long_usage ]]; then
      printf "Options:\n"
      # :command.usage_fixed_flags
      echo "  --help, -h"
      printf "    Show this help\n"
      echo

      # :command.usage_args
      printf "Arguments:\n"

      # :argument.usage
      echo "  GO_VERSION"
      printf "    The version of Go to install\n"
      echo

    fi
  }

  # :command.usage
  gvm_install_usage() {
    if [[ -n $long_usage ]]; then
      printf "gvm install - Install a version of Go\n"
      echo

    else
      printf "gvm install - Install a version of Go\n"
      echo

    fi

    printf "Usage:\n"
    printf "  gvm install [GO_VERSION]\n"
    printf "  gvm install --help | -h\n"
    echo

    if [[ -n $long_usage ]]; then
      printf "Options:\n"
      # :command.usage_fixed_flags
      echo "  --help, -h"
      printf "    Show this help\n"
      echo

      # :command.usage_args
      printf "Arguments:\n"

      # :argument.usage
      echo "  GO_VERSION"
      printf "    The version of Go to install\n"
      echo

    fi
  }

  # :command.normalize_input
  normalize_input() {
    local arg flags

    while [[ $# -gt 0 ]]; do
      arg="$1"
      if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
        input+=("${BASH_REMATCH[1]}")
        input+=("${BASH_REMATCH[2]}")
      elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
        input+=("${BASH_REMATCH[1]}")
        input+=("${BASH_REMATCH[2]}")
      elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
        flags="${BASH_REMATCH[1]}"
        for (( i=0 ; i < ${#flags} ; i++ )); do
          input+=("-${flags:i:1}")
        done
      else
        input+=("$arg")
      fi

      shift
    done
  }
  # :command.inspect_args
  inspect_args() {
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    if (( ${#args[@]} )); then
      echo args:
      for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
    else
      echo args: none
    fi

    if (( ${#other_args[@]} )); then
      echo
      echo other_args:
      echo "- \${other_args[*]} = ${other_args[*]}"
      for i in "${!other_args[@]}"; do
        echo "- \${other_args[$i]} = ${other_args[$i]}"
      done
    fi
  }

  # :command.command_functions
  # :command.function
  gvm_init_command() {
    # src/init_command.sh
    if [[ $EUID != 0 ]]; then
      cmd="$0 $action"
      echo "Root required, running: sudo $cmd"
      sudo $cmd
      exit $?
    fi

    go_dir=$(cd $(dirname $(which go))/.. && pwd)
    real_go_dir=${go_dir}
    cur_go_version=$(go version | cut -d ' ' -f3 | sed 's/go//')

    while [[ -L ${real_go_dir} ]]; do
      real_go_dir=$(ls -l ${real_go_dir} | cut -d '>' -f 2 | sed "s/ //")
    done

    if [[ ${real_go_dir} =~ ${go_sdk_dir}/* ]]; then
      echo "Detected using Go SDKs, running 'gvm use ${cur_go_version}'"
      $0 use ${cur_go_version}
      if [[ $? != 0 ]]; then
        exit $?
      fi
      sudo rm ${go_dir}
      ln -s ${go_cur_sdk} ${go_dir}
      echo "Go environment is now compatible with 'gvm'"
      exit
    fi

    if [[ ! -d ${go_sdk_dir} ]]; then
      mkdir ${go_sdk_dir}
    fi

    sudo mv ${go_dir} ${go_sdk_dir}/go${cur_go_version}
    $0 use ${cur_go_version}
    if [[ $? != 0 ]]; then
      exit $?
    fi
    sudo ln -s ${go_cur_sdk} ${go_dir}
    echo "Go environment is now compatible with 'gvm'"
  }

  # :command.function
  gvm_list_command() {
    # src/list_command.sh
    installed_go_sdks=($(ls ${go_sdk_dir} | grep go | grep -v current | sed 's/go//' | xargs))
    cur_go_version=$(ls -l ${go_cur_sdk} | cut -d '>' -f 2 | sed "s| *${go_sdk_dir}/go||")

    echo "Installed Go SDKs:"
    for g in ${installed_go_sdks[@]}; do
      if [[ $g == ${cur_go_version} ]]; then
        echo "  - $g *"
      else
        echo "  - $g"
      fi
    done
  }

  # :command.function
  gvm_use_command() {
    # src/use_command.sh
    go_version=${args[go_version]}
    go_bin=${go_bin_dir}/go${go_version}
    go_sdk=${go_sdk_dir}/go${go_version}

    if [[ ! -d $go_sdk ]] || [[ ! -f $go_bin ]]; then
      echo "Go v${go_version} not installed, run 'gvm install ${go_version}'"
      exit 0
    fi

    if [[ -f ${go_cur_sdk} ]]; then
      rm ${go_cur_sdk}
    fi

    rm ${go_cur_sdk} 2> /dev/null || true
    ln -s ${go_sdk} ${go_cur_sdk}
  }

  # :command.function
  gvm_install_command() {
    # src/install_command.sh
    go_version=${args[go_version]}
    go_bin=${go_bin_dir}/go${go_version}
    go_sdk=${go_sdk_dir}/go${go_version}

    if [[ -d $go_sdk ]]; then
      echo "Go v${go_version} already installed"
      exit 0
    fi

    if [[ ! -f $go_bin ]]; then
      echo "Installing Go v${go_version}"
      go install golang.org/dl/go${go_version}@latest
    fi

    echo "Downloading Go v${go_version} SDK"
    eval "go${go_version} download"

    eval "go${go_version} version"

    echo "Use 'gvm use ${go_version}' to set as default"
  }

  # :command.parse_requirements
  parse_requirements() {
    # :command.fixed_flags_filter
    case "${1:-}" in
    --version | -v )
      version_command
      exit
      ;;

    --help | -h )
      long_usage=yes
      gvm_usage
      exit
      ;;

    esac
    # :command.environment_variables_filter
    # :command.dependencies_filter
    # :command.command_filter
    action=${1:-}

    case $action in
    -* )
      ;;

    init )
      action="init"
      shift
      gvm_init_parse_requirements "$@"
      shift $#
      ;;

    list )
      action="list"
      shift
      gvm_list_parse_requirements "$@"
      shift $#
      ;;

    use )
      action="use"
      shift
      gvm_use_parse_requirements "$@"
      shift $#
      ;;

    install )
      action="install"
      shift
      gvm_install_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    * )
      gvm_usage
      exit 1
      ;;

    esac
    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
      key="$1"
      case "$key" in

      -?* )
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      * )
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

      esac
    done
    # :command.required_args_filter
    # :command.required_flags_filter
    # :command.catch_all_filter
    # :command.default_assignments
    # :command.whitelist_filter
    # :command.user_filter
  }

  # :command.parse_requirements
  gvm_init_parse_requirements() {
    # :command.fixed_flags_filter
    case "${1:-}" in
    --help | -h )
      long_usage=yes
      gvm_init_usage
      exit
      ;;

    esac
    # :command.environment_variables_filter
    # :command.dependencies_filter
    if ! [[ -x "$(command -v go)" ]]; then
      printf "missing dependency: go\n"
      exit 1
    fi
    # :command.command_filter
    action="init"
    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
      key="$1"
      case "$key" in

      -?* )
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      * )
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

      esac
    done
    # :command.required_args_filter
    # :command.required_flags_filter
    # :command.catch_all_filter
    # :command.default_assignments
    # :command.whitelist_filter
    # :command.user_filter
  }

  # :command.parse_requirements
  gvm_list_parse_requirements() {
    # :command.fixed_flags_filter
    case "${1:-}" in
    --help | -h )
      long_usage=yes
      gvm_list_usage
      exit
      ;;

    esac
    # :command.environment_variables_filter
    # :command.dependencies_filter
    # :command.command_filter
    action="list"
    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
      key="$1"
      case "$key" in

      -?* )
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      * )
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

      esac
    done
    # :command.required_args_filter
    # :command.required_flags_filter
    # :command.catch_all_filter
    # :command.default_assignments
    # :command.whitelist_filter
    # :command.user_filter
  }

  # :command.parse_requirements
  gvm_use_parse_requirements() {
    # :command.fixed_flags_filter
    case "${1:-}" in
    --help | -h )
      long_usage=yes
      gvm_use_usage
      exit
      ;;

    esac
    # :command.environment_variables_filter
    # :command.dependencies_filter
    # :command.command_filter
    action="use"
    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
      key="$1"
      case "$key" in

      -?* )
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      * )
        # :command.parse_requirements_case
        if [[ -z ${args[go_version]+x} ]]; then
          # :argument.validations
          args[go_version]=$1
          shift
        else
          printf "invalid argument: %s\n" "$key"
          exit 1
        fi
        ;;

      esac
    done
    # :command.required_args_filter
    # :command.required_flags_filter
    # :command.catch_all_filter
    # :command.default_assignments
    # :command.whitelist_filter
    # :command.user_filter
  }

  # :command.parse_requirements
  gvm_install_parse_requirements() {
    # :command.fixed_flags_filter
    case "${1:-}" in
    --help | -h )
      long_usage=yes
      gvm_install_usage
      exit
      ;;

    esac
    # :command.environment_variables_filter
    # :command.dependencies_filter
    if ! [[ -x "$(command -v go)" ]]; then
      printf "missing dependency: go\n"
      exit 1
    fi
    # :command.command_filter
    action="install"
    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
      key="$1"
      case "$key" in

      -?* )
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      * )
        # :command.parse_requirements_case
        if [[ -z ${args[go_version]+x} ]]; then
          # :argument.validations
          args[go_version]=$1
          shift
        else
          printf "invalid argument: %s\n" "$key"
          exit 1
        fi
        ;;

      esac
    done
    # :command.required_args_filter
    # :command.required_flags_filter
    # :command.catch_all_filter
    # :command.default_assignments
    # :command.whitelist_filter
    # :command.user_filter
  }

  # :command.initialize
  initialize() {
    version=""
    long_usage=''
    set -e

    # src/initialize.sh

    go_bin_dir=${HOME}/go/bin
    go_sdk_dir=${HOME}/sdk
    go_cur_sdk=${go_sdk_dir}/gocurrent
  }

  # :command.run
  run() {
    declare -A args=()
    declare -a other_args=()
    declare -a input=()
    normalize_input "$@"
    parse_requirements "${input[@]}"

    if [[ $action == "init" ]]; then
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        gvm_init_usage
      else
        gvm_init_command
      fi

    elif [[ $action == "list" ]]; then
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        gvm_list_usage
      else
        gvm_list_command
      fi

    elif [[ $action == "use" ]]; then
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        gvm_use_usage
      else
        gvm_use_command
      fi

    elif [[ $action == "install" ]]; then
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        gvm_install_usage
      else
        gvm_install_command
      fi

    elif [[ $action == "root" ]]; then
      root_command
    fi
  }

  initialize
  run "$@"
}

(return 0 2>/dev/null) || run_gvm "$@"
